 LUI		0110111		Rd := 0 + imm20
 AUIPC		0010111		Rd := IP + imm20
 JAL		1101111		Rd := IP + 4; PC := disp21 + IP; flushPipe
 JALR		1100111		Rd := IP + 4; PC := Rs1 + imm12; flushPipe
 Bcc		1100011.ccc	IF Rs1 .op. Rs2 THEN PC := IP + disp13; flushPipe THEN
 Lx		0000011.xxx	Rd := MEMx(Rs1+imm12)
 Sx		0100011.xxx	MEMx(Rs1+imm12) := Rd
 aluI		0010011.fff	Rd := Rs1 .op. imm12
alu		0110011.fff	Rd := Rs1 .op. Rs2
 FENCE		0001111		(no operation)
 FENCE.I	0001111		(no operation)
 CSRRx		1110011.0xx	(needs more thought; xx != 0)
 CSRRxI		1110011.1xx	(reuse logic from CSRRx; xx != 0)

I find it really hard to believe that there is only 13 distinct classes of instructions I need to support in user-mode, 11 of which are actually useful for me.  I mean, the Func3 fields are not taken into consideration, but they can be combinatorially decoded in parallel and dealt with.  But, then again, I suppose that's the value of RISC over CISC.  See also Data General Nova architecture, which only had something like 4 or 6 actual instructions; the rest were simple tweaks on the theme.

